//1. 
let a = +prompt("Enter a value for a ", 0);
let b = +prompt("Enter a value for b ", 0);

console.log (a + b);

//2. 
// console.log( 1.35.toFixed(1) ); // 1.4
// console.log( 6.35.toFixed(1) ); // 6.3
// This is because of the binary representation of 6.35 leading to a precision issue, where
// 6.35 becomes a number slightly less than 6.35 and therefore rounds down to 6.3
// To properly round, you should use multiply 6.35 by 10, use math.round(), and then divide by 10:
// console.log( Math.round( 6.35 * 10 ) / 10 );

//3. 
function readNumber() {
let num = NaN;

while(isNaN(num)){
    num = prompt("Enter a number ", 0);
    if(num == null || num == ""){
        return null;
    }
    num = +num;
}

return num;

}
console.log(readNumber());

//4. 
// This loop is infinite because of rounding errors. After 5 iterations i should be 10.0, 
// but is likely either a little bit over or under due to binary representation.
let i = 0;
while (i != 10) {
  i += 0.2;
}

//5. 
// This function returns a random number between min and max
function random(min, max){
   return (Math.random() * (max-min)) + min;
}

// It works because first we are adding min to whatever result comes from within the
// parentheses, which creates a lower bound of at least min. Then, Math.random() 
// generates a number between 0 and 1, which is then a ratio applied to (max - min).
// Even if Math.random() could generate a 1, the maximum value that could come out is:
// (1 * (max - min) + min) = (max - min) + min = max. If Math.random() outputs 0,
// the result is (0 * (max - min)) + min = 0 + min = min. It is important to note that we 
// can never get exactly max due to Math.random() being from [0, 1) (exclusive for 1).

//6. 
// This function returns a random integer between min and max
function randomInteger(min, max){
    return Math.round((Math.random() * (max-min)) + min);
}

// It works because of the same reason the function in #5 works, plus Math.round() is 
// used to round to the nearest number. But, this is technically logically flawed in 
// that not every number has an even chance at being generated. Javascript.info gives 
// the reasoning using the interval 1..3: values from 1.0 to 1.4999999 round to 1, 
// values 1.5 to 2.4999999 round to 2, and values from 2.5 to 3.4999999 round to 3. 
// This means that there are twice as many numbers that allow 2 to be generated than 1 or 2 have.

// A solution that is correct is given as:
function randomInteger(min, max) {
  // now rand is from  (min-0.5) to (max+0.5)
  let rand = min - 0.5 + Math.random() * (max - min + 1);
  return Math.round(rand);
}

// The above essentially pads the numbers on the edges (min/max) to give them the same number of
// numbers that can lead to them being generated by Math.round() as the numbers between min/max.